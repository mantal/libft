/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   socket.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlancar <dlancar@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2015/03/19 16:43:03 by dlancar           #+#    #+#             */
/*   Updated: 2015/03/19 17:29:10 by dlancar          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include <error.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <netdb.h>
#include <netinet/in.h>

#include "net.h"

#define SOCKET_BACKLOG 64

static int	(*g_default_accept)(t_socket *, int) = socket_accept;
static int	(*g_default_read)() = NULL;
static int	(*g_default_write)() = NULL;

t_socket	*socket_create(void)
{
	t_socket		*res;
	struct protoent	*proto;
	struct rlimit	rlimit;
	int				i;

	res = ft_malloc(sizeof(t_socket));
	proto = getprotobyname("tcp");
	res->fd = socket(PF_INET, SOCK_STREAM, proto->p_proto);
	if (res->fd < 0 || getrlimit(RLIMIT_NOFILE, &rlimit) < 0)
	{
		free(res);
		ft_error();
		return (NULL);
	}
	res->nfds = 0;
	i = 0;
	res->fds = ft_malloc(rlimit.rlim_cur * sizeof(t_fd));
	res->fds_size = rlimit.rlim_cur;
	while (++i < res->fds_size)
		socket_clean_fd(&res->fds[i]);
	res->fds[res->fd].type = SOC_SERVER;
	res->fds[res->fd].on_read = g_default_accept;
	return (res);
}

t_socket	*socket_bind(t_socket *soc, int port)
{
	struct sockaddr_in	addr;

	ft_memset(&addr, 0, sizeof(struct sockaddr_in));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = INADDR_ANY;
	addr.sin_port = htons(port);
	if (bind(soc->fd, (const struct sockaddr*)&addr, sizeof(struct sockaddr_in))
			< 0)
	{
		ft_error();
		return (NULL);
	}
	soc->port = port;
	return (soc);
}

t_socket	*socket_listen(t_socket *soc)
{
	if (listen(soc->fd, SOCKET_BACKLOG) < 0)
	{
		ft_error();
		return (NULL);
	}
	return (soc);
}

int			socket_accept(t_socket *soc, int cs)
{
	struct sockaddr_in	addr;
	socklen_t			addr_len;
	int					res;

	(void)cs;
	addr_len = sizeof(struct sockaddr_in);
	res = accept(soc->fd, (struct sockaddr*)&addr, &addr_len);
	if (res < 0)
	{
		ft_error();
		return (-1);
	}
	socket_clean_fd(&soc->fds[res]);
	soc->fds[res].type = SOC_CLIENT;
	return (res);
}

void		socket_clean_fd(t_fd *fd)
{
	fd->type = SOC_FREE;
	fd->on_read = g_default_read;
	fd->on_write = g_default_write;
}
